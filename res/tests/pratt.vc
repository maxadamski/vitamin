
op(10, core-par, `( _? )`)
op(11, core-blk, `{ _? }`)
op(12, core-set, `_ = _`)
op(13, core-def, `macro _ = _`)
op(13, core-let, `let _ = _`)
op(15, core-loop, `while _ { _? }`)
op(15, core-cond, `if _ { _ } else { _ }`)
op(18, core-list, `_ , _+`)
op(20, core-fun, `_ => _`)
op(21, core-pair, `_ -> _`)
op(22, core-type, `_ : _`)
op(60, sys_arr_get, `_ [ _ ]`)
//op(50, _, `_ ( _ , _+ )`)
//op(51, cast, `_ as _!`)
op(61, sys_lt_I32, `_ < _!`)
op(62, sys_add_I32, `_ + _!`)

/*
op-group(op-fun, mix)
op-power(op-fun, more-than())
op(op-fun, core-fun, ``)
*/

macro core-blk(x) = x
macro core-par(x) = x
macro print(x) = quasiquote(sys_fos_write(sys_stdout, unquote(x)))
macro len(x) = quasiquote(sys_arr_len(unquote(x)))
macro cfor(x, y, z, body) = quasiquote({
    unquote(x)
    while unquote(y) {
        unquote(body)
        unquote(z)
    }
})

/*
protocol Show(a)   { let show: a -> String }

let f: a -> B where Proto(a)
let x: A

f(x) ? x == f.arg-types

A == a where Proto(A)
if A in Proto
    A == a
else
    type class error

instance Show(I8)  { let show = sys_I8_to_Str }
instance Show(I16) { let show = sys_I16_to_Str }
instance Show(I32) { let show = sys_I32_to_Str }
instance Show(I64) { let show = sys_I64_to_Str }
instance Show(F32) { let show = sys_F32_to_Str }
instance Show(F64) { let show = sys_F64_to_Str }
*/


let print-str = (s: Array(I8)) -> Unit => {
    let i = 0
    while i < len(s) {
        let byte = s[i]
        print(sys_I8_to_Str(byte))
        i = sys_add_I32(i, 1)
    }
}

let void = () -> Unit => { print-str("void") }
let noid = void

print-str("void")
void()
noid()
