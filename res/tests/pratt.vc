
op(10, core-par, `( _? )`)
op(11, core-blk, `{ _? }`)
op(12, core-set, `_ = _`)
op(13, core-def, `macro _ = _`)
op(13, core-let, `let _ = _`)
op(15, core-loop, `while _ { _? }`)
op(15, core-cond, `if _ { _ } else { _ }`)


op(18, core-list, `_ , _+`)

op(20, core-fun, `_ => _`)
op(21, core-pair, `_ -> _`)
op(22, core-type, `_ : _`)

op(60, sys_arr_get, `_ [ _ ]`)

//op(50, _, `_ ( _ , _+ )`)

//op(51, cast, `_ as _!`)

op(61, sys_lt_I32, `_ < _!`)

op(62, sys_add_I32, `_ + _!`)

/*
op-group(op-fun, mix)
op-power(op-fun, more-than())
op(op-fun, core-fun, ``)
*/

macro core-blk(x) = x
macro core-par(x) = x
macro print(x) = quasiquote(sys_fos_write(sys_stdout, unquote(x)))
macro len(x) = quasiquote(sys_arr_len(unquote(x)))
macro cfor(x, y, z, body) = quasiquote({
    unquote(x)
    while unquote(y) {
        unquote(body)
        unquote(z)
    }
})


//sys_fos_write(sys_stdout, sys_I64_to_Str(sys_add_I64(2, 3)))
//println(sys_I64_to_Str(10))
//var x: I32 = hoola hoop

// lambda syntax
//let f1 = x => nil
//let f2 = x, y => nil
//let f3 = x: A => nil
//let f3 = (x: A) => nil
//let f4 = (x: A, y: B) => nil
//let f5 = (x: A, y: B) -> C => nil

/*
protocol Show(a)   { let show: a -> String }

let f: a -> B where Proto(a)
let x: A

f(x) ? x == f.arg-types

A == a where Proto(A)
if A in Proto
    A == a
else
    type class error

instance Show(I8)  { let show = sys_I8_to_Str }
instance Show(I16) { let show = sys_I16_to_Str }
instance Show(I32) { let show = sys_I32_to_Str }
instance Show(I64) { let show = sys_I64_to_Str }
instance Show(F32) { let show = sys_F32_to_Str }
instance Show(F64) { let show = sys_F64_to_Str }
*/


let print-str = (s: Array(I8)) -> Unit => {
    let i = 0
    while i < len(s) {
        let byte = s[i]
        print(sys_I8_to_Str(byte))
        i = sys_add_I32(i, 1)
    }
}

let void = () -> Unit => { print-str("void") }
let noid = void

print-str("void")
void()
noid()



// https://akuklev.livejournal.com/1139711.html
// "adjacent operators are in non-associative precedence group"
//
// a directed edge a -> b means "a binds more than b"
// prefix operators are non-associative or right-associative
// suffix operators are non-associative or left-associative
// operator group can only

//(200, _, `_ ( _ , # )`)
//(200, _, `_ ( _ )`)
//(200, _, `_ ( )`)

/*
op(300, let, `let _ = _`)
op(350, describe, `describe _ { _ }`)
op(350, it, `it _ { _ }`)
*/

