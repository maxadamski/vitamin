// comment
// nested // comment
/* comment */
/* nested /* /* comment */ */ */
/* multi
    line
    /* nested
        comment */
      */
hello world
stat1
stat2
0 1 1_000_000 0766 1_ 00000 10__000__000
3.1415 1.0 0.123
//2#0 2#1 2#1100_1100 2#10
//16#0 16#123456ABCDEF 16#ffff33 16#Dead_Beef
//8#0 8#766 8#1_234_567
//36#0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
//42i 1e9 1E9 1e+9 1.12e-6 2.0i
//0b0 0b1 0b1100_1100
//0o0 0o766 0o1_234_567
//0x0 0x123456ABCDEF 0xffff33 0xDead_Beef
()
{}
{ x y z }
{
    a b c
    x y z \
    u v w
}
(x y z)
(x (a b c))
(
    a b c
    d e f
    x \ {
        a b c
        d e f
    }
)
(1 2 3 4)
eye = (
    1 0 0 0
    0 1 0 0
    0 0 1 0
    0 0 0 1
)
"a string"
"an \" escaped \" string"
"cannot " nest " strings"
raw"string with a sigil"

"""big string"""
json"""big string with a sigil"""
"""big " strings don't "" need \""" many escapes"""
"""
    multi-line
    strings for
    the win!
"""
"""some \n escapes \t and \  such \\"""
"""intepolation is ${x + 2} not $done during lexing"""

expr;expr
expr,expr

@annotation
#core_form
hello!
h_e_l__lo?
hello:world
hello::world
x++y**z
xyz
x+y*z
x->y
x.y

callee(x, y, z)
not_callee (x, y, z)
foo
foo()
foo(x)
foo(x)(y)(z)
foo(x, y)(z, q)
(x foo y)(z)
{ s1; s2 }(x)(y)
x * (y + z)
x *(y + z)
(x) -> (y)
(x)->(y)

if (x) {
    false
} else {
    true
}
